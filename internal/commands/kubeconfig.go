package commands

import (
	"context"
	"encoding/base64"
	"fmt"

	"github.com/spf13/cobra"

	"github.com/projectsveltos/sveltosctl/internal/config"

	ictx "github.com/projectsveltos/sveltosctl/internal/ctx"
)

type kubeconfigOptions struct {
	Namespace           string
	ServiceAccount      string
	Create              bool
	ExpirationSeconds   int
	ServiceAccountToken bool
}

const (
	kubeConfigCtxKey = ictx.ContextKey("cmdKubeConfigOptions")
)

func newKubeconfigOptions() *kubeconfigOptions {
	return &kubeconfigOptions{}
}

func newKubeConfigOptionsWithContext(ctx context.Context) context.Context {
	kco := newKubeconfigOptions()
	ctx = context.WithValue(ctx, kubeConfigCtxKey, kco)
	return ctx
}

func getKubeConfigOptions(ctx context.Context) *kubeconfigOptions {
	kco, ok := ctx.Value(kubeConfigCtxKey).(*kubeconfigOptions)
	if !ok || kco == nil {
		panic("no kubeconfig options found in context")
	}
	return kco
}

func cmdKubeconfig(ctx context.Context) *cobra.Command {
	kubeConfigCmdOptions := getKubeConfigOptions(ctx)
	kubeConfigCmd := &cobra.Command{
		Use: "kubeconfig",
		Short: `This command helps you set up credentials (generate) to access a Kubernetes cluster using Sveltos. It allows you to specify a ServiceAccount
or create a new one with the necessary permissions.`,
		Long: `Sveltos will either use an existing ServiceAccount with sufficient permissions (if --create is not set) or create a new one with
		cluster-admin permissions (if --create is set).
		Sveltos will generate a TokenRequest for the chosen ServiceAccount. Based on the TokenRequest, Sveltos will generate a generate
		file and output it.
		The Kubeconfig can then be used with "sveltosctl register cluster" command.`,

		RunE: func(cmd *cobra.Command, args []string) error {
			tctx := cmd.Context()
			kco := getKubeConfigOptions(tctx)
			//logger := logging.LoggerFromContext(tctx)
			cfg := config.CtlConfigFromContext(tctx)
			err := kubeConfigForServiceAccount(cfg, kco.Namespace, kco.ServiceAccount, kco.ExpirationSeconds, kco.Create, kco.ServiceAccountToken)
			if err != nil {
				return err
			}
			return nil
		},
	}
	kubeConfigCmd.Flags().StringVarP(
		&kubeConfigCmdOptions.Namespace,
		"namespace",
		"n", config.ProjectSveltos,
		"Specifies the namespace of the ServiceAccount to use. Defaults to \"projectsveltos\"")
	kubeConfigCmd.Flags().StringVar(&kubeConfigCmdOptions.ServiceAccount,
		"serviceaccount", config.ProjectSveltos,
		"Specifies the name of the ServiceAccount to use. Defaults to \"projectsveltos\"")
	kubeConfigCmd.Flags().BoolVar(&kubeConfigCmdOptions.Create, "create", false,
		`If set, Sveltos will create the necessary resources if they don't already exist:
- The specified namespace (if not already present)
- The specified ServiceAccount (if not already present)
- A ClusterRole with cluster-admin permissions
- A ClusterRoleBinding granting the ServiceAccount cluster-admin permissions

Defaults to false.
`)
	kubeConfigCmd.Flags().IntVar(&kubeConfigCmdOptions.ExpirationSeconds, "expirationSeconds", 0,
		`This option allows you to specify the desired validity period
(in seconds) for the token requested when generating a generate.
Minimum value is 600 (10 minutes).
If you don't provide this option, the issuer (where the generate points)
will use its default expiration time for the token.
Once you register a cluster using the generate generated by this command,
you can manage automatic token renewal through the
SveltosCluster.Spec.TokenRequestRenewalOption setting within the registered
SveltosCluster resource. This provides more control over token expiration and
renewal behavior.

Defaults to 0.
`)
	kubeConfigCmd.Flags().BoolVar(&kubeConfigCmdOptions.ServiceAccountToken, "service-account-token", false,
		`Use a non-expiring ServiceAccount token for management cluster registration.
When enabled, Sveltos will automatically create the necessary ServiceAccount infrastructure
(ServiceAccount, ClusterRole, and ClusterRoleBinding) in the managed cluster and
generate a long-lived token by also creating a Secret of type kubernetes.io/service-account-token.

Defaults to false.
`)
	return kubeConfigCmd
}

func kubeConfigForServiceAccount(cfg *config.CtlConfig, namespace, serviceAccountName string, expirationSeconds int, create, satoken bool) error {
	var err error
	k8sCluster := cfg.MgmtCluster()
	if create {
		err = k8sCluster.CoreResources.Create(namespace)
		if err != nil {
			return err
		}
		err = k8sCluster.CoreResources.CreateServiceAccount(serviceAccountName, namespace)
		if err != nil {
			return err
		}
		err = k8sCluster.CoreResources.CreateClusterRole(config.ProjectSveltos)
		if err != nil {
			return err
		}
		err = k8sCluster.CoreResources.CreateClusterRoleBinding(config.ProjectSveltos, config.ProjectSveltos, namespace, serviceAccountName)
	} else {
		_, err = k8sCluster.CoreResources.Get(namespace)
		if err != nil {
			return err
		}
		_, err = k8sCluster.CoreResources.GetServiceAccount(serviceAccountName, namespace)
		if err != nil {
			return err
		}
	}

	var token string
	if satoken {
		if err = k8sCluster.CoreResources.CreateSecret(namespace, serviceAccountName); err != nil {
			return err
		}
		token, err = k8sCluster.CoreResources.GetToken(namespace, serviceAccountName)
		if err != nil {
			return err
		}
	} else {
		tokenReq, err := k8sCluster.CoreResources.CreateToken(namespace, serviceAccountName, expirationSeconds)
		if err != nil {
			return err
		}
		token = tokenReq.Status.Token
	}
	cfg.Logger().Info("Get Kubeconfig from TokenRequest")
	data := getKubeconfigFromToken(cfg, namespace, serviceAccountName, token)
	if cfg.Verbose {
		//nolint: forbidigo // print generate
		cfg.Logger().Info("Kubeconfig:", "kubeconfig", string(data))
	}

	return nil
}

// getKubeconfigFromToken returns Kubeconfig to access management cluster from token.
func getKubeconfigFromToken(cfg *config.CtlConfig, namespace, serviceAccountName, token string) string {
	template := `apiVersion: v1
kind: Config
clusters:
- name: local
 cluster:
   server: %s
   certificate-authority-data: "%s"
users:
- name: %s
 user:
   token: %s
contexts:
- name: sveltos-context
 context:
   cluster: local
   namespace: %s
   user: %s
current-context: sveltos-context`

	data := fmt.Sprintf(template, cfg.MgmtCluster().RestConfig().Host,
		base64.StdEncoding.EncodeToString(cfg.MgmtCluster().RestConfig().CAData), serviceAccountName, token, namespace, serviceAccountName)

	return data
}
